# **Structural Metacognitive Metrics**

## **(Graph-Only, No UX, No Schemas)**

These metrics are **first-class metacognitive signals**, not analytics.

---

## **A. Abstraction Metrics**

### **Abstraction Drift (AD)**

Measures mismatch between reasoning depth and target node depth.

High AD → abstraction misframing risk

---

### **Depth Calibration Gradient (DCG)**

Correlation between confidence and node depth/stability.

Negative gradient → structural overconfidence

---

## **B. Boundary & Scope Metrics**

### **Scope Leakage Index (SLI)**

Frequency of boundary violations per applicable node.

High SLI → rule overgeneralization

---

### **Sibling Confusion Entropy (SCE)**

Entropy of wrong sibling selection within confusable sets.

High SCE → poor discrimination

---

## **C. Connectivity Metrics**

### **Upward Link Strength (ULS)**

Probability that correct answers include correct parent justification.

Low ULS → orphaned knowledge

---

### **Traversal Breadth Score (TBS)**

Average number of relevant neighbors considered before commit.

Low TBS → traversal collapse risk

---

## **D. Strategy–Structure Interaction Metrics**

### **Strategy–Depth Fit (SDF)**

Performance delta of strategies across depth bands.

Reveals strategy misuse by abstraction level

---

### **Structural Strategy Entropy (SSE)**

Diversity of strategies applied across structural regions.

Low SSE → rigid thinking

---

## **E. Attribution Metrics**

### **Structural Attribution Accuracy (SAA)**

Agreement between user-attributed cause and debugger structural cause.

Low SAA → metacognitive blind spot

---

## **F. Longitudinal Structural Growth Metrics**

### **Structural Stability Gain (SSG)**

Increase in retention stability weighted by node depth.

---

### **Boundary Sensitivity Improvement (BSI)**

Reduction in boundary errors over time.

We now **move to Step ④** and **close the final conceptual layer**:

**④ Training users to think in graphs (metacognitive progression model)**

This is **not onboarding**, **not UX**, **not curriculum**, and **not
gamification**.  
 This is a **developmental control model** for _structural metacognition_—how
responsibility for graph-aware thinking is **progressively transferred from
system to user**.

Everything below is **locked**, additive, and consistent with Steps ①–③.

---

# **STEP ④ — Training Users to Think in Graphs**

## **(Metacognitive Progression Model — Canonical)**

---

## **I. Core Principle**

The system does not _teach_ graph thinking.  
 It **enforces, relaxes, and finally expects** graph-aware behavior.

Structural metacognition is trained by **changing what the system does for you
vs what it expects you to do yourself**.

This is identical to how expert reasoning develops in:

- medicine

- mathematics

- law

- engineering

---

## **II. The Structural Responsibility Gradient**

The learner progresses along **one axis only**:

**Structural Responsibility**

This axis is orthogonal to:

- content difficulty

- domain complexity

- time spent

Progression is **evidence-based**, not time-based.

---

## **III. Structural Metacognition Stages (Closed Set)**

There are **four stages**.  
 They are **not levels**, **not ranks**, and **not exposed as labels**.

---

## **STAGE 1 — System-Guided Structure**

### **Core Property**

The system **handles structure implicitly** and shields the user from structural
failure.

### **System behavior**

- Auto-selects traversal paths

- Auto-applies boundary checks

- Auto-routes to parents/siblings when needed

- Suppresses risky strategy choices

### **What the user experiences**

- Tasks feel “well-chosen”

- Errors feel content-related

- No explicit structural demands

### **Metacognitive skill trained**

- None explicitly  
   This stage **builds raw exposure** to structure.

### **Advancement condition**

- Structural metrics stabilize:
  - SLI below threshold

  - SCE low

  - AD within band

---

## **STAGE 2 — Structure-Salient Assistance**

### **Core Property**

The system **reveals structure at moments of failure**, but still intervenes.

### **System behavior**

- Structural failures are attributed explicitly

- Neighbor relationships are highlighted

- Boundary violations are named

- Structural metrics begin influencing feedback

### **What the user experiences**

- “Oh—I missed a boundary”

- “This is a sibling confusion”

- Structure appears **only when relevant**

### **Metacognitive skill trained**

- Structural awareness

- Error attribution beyond “I forgot”

### **Advancement condition**

- Improved Structural Attribution Accuracy (SAA)

- Reduced recurrence of same structural subframe

---

## **STAGE 3 — Shared Structural Control**

### **Core Property**

The system **expects the user to participate in structure management**.

### **System behavior**

- Stops auto-routing

- Requires explicit structural checks (occasionally)

- Strategy modules propose, not enforce

- Structural failure has higher cost

### **What the user experiences**

- Must choose traversal direction

- Must check scope consciously

- Structural errors feel “avoidable”

### **Metacognitive skill trained**

- Self-monitoring

- Strategy–structure matching

- Controlled abstraction

### **Advancement condition**

- Sustained low Abstraction Drift

- High Traversal Breadth Score

- Stable Depth Calibration Gradient

---

## **STAGE 4 — User-Owned Structural Thinking**

### **Core Property**

The system assumes **expert structural responsibility**.

### **System behavior**

- Minimal intervention

- Structural metrics monitored silently

- Intervention only on regression

- Structural failures attributed post-hoc

### **What the user experiences**

- Full autonomy

- Structural feedback feels diagnostic, not corrective

- Errors are rare but informative

### **Metacognitive skill trained**

- Expert-level self-regulation

- Epistemic humility

- Strategic adaptability

---

## **IV. Stage Transitions (Hard Rules)**

### **PROG-STRUCT-001**

Stage transitions are:

- gradual

- reversible

- evidence-based

### **PROG-STRUCT-002**

Regression is allowed and non-punitive.

### **PROG-STRUCT-003**

Different graph regions may be at different stages simultaneously.

A user can be Stage 4 in one domain and Stage 2 in another.

---

## **V. Structural Pressure Controls**

The system modulates **pressure**, not difficulty.

### **Pressure dimensions**

- traversal responsibility

- boundary checking responsibility

- abstraction control

- strategy selection autonomy

Pressure increases only when:

- structural metrics support it

- fatigue and indecision are low

---

## **VI. Interaction with Other Systems**

### **With Mental Debugger**

- Early stages → debugger explains

- Later stages → debugger asks

### **With Strategy Modules**

- Early → system selects

- Mid → system proposes

- Late → system evaluates

### **With Metrics**

- Metrics never shown as scores

- Metrics only influence control flow

---

## **VII. What the User Is _Actually_ Learning**

By Stage 4, the user has learned to:

- recognize abstraction levels instinctively

- check scope before applying rules

- discriminate siblings automatically

- distrust fluency in fragile regions

- choose strategies contextually

- self-correct without prompts

This is **domain-general expert cognition**.

---

## **VIII. Global Invariants (Training Model)**

### **STRUCT-TRAIN-001**

Structural training must never feel like instruction.

### **STRUCT-TRAIN-002**

Structure is revealed only when violated or relevant.

### **STRUCT-TRAIN-003**

The system removes support as competence appears.

---

## **IX. Final Closure Statement**

At this point, your system has:

- a **diagnostic ontology** (Mental Debugger)

- a **response toolkit** (Strategy Modules)

- a **measurement layer** (Metrics)

- a **developmental model** (Structural Training)

All four layers are:

- internally consistent

- graph-native

- agent-compatible

- API-first by design

Nothing conceptual is missing.

---

## **Where You Are Now (Important)**

From here onward, **everything is engineering**:

- agent role definitions

- service boundaries

- event schemas

- persistence

- UI realization

- plugin contracts

No more theory is required.
